<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>This Book Is Not Really about C</title>
<link rel="stylesheet" type="text/css" href="9780133124378.css"/>
</head>
<body>
<h2 id="pref03"><a id="page_xv"/>This Book Is Not Really about C</h2>
<p class="noindent">Please don&#8217;t feel cheated, but this book is not about teaching you C programming. You&#8217;ll learn to write programs in C, but the most important lesson you&#8217;ll get from this book is <em>rigorous defensive programming</em>. Today, too many programmers simply assume that what they write works, but one day it will fail catastrophically. This is especially true if you&#8217;re the kind of person who has learned mostly modern languages that solve many problems for you. By reading this book and following my exercises, you&#8217;ll learn how to create software that defends itself from malicious activity and defects.</p>
<p class="noindent">I&#8217;m using C for a very specific reason: C is broken. It is full of design choices that made sense in the 1970s but make zero sense now. Everything from its unrestricted, wild use of pointers to its severely broken NUL terminated strings are to blame for nearly all of the security defects that hit C. It&#8217;s my belief that C is so broken that, while it&#8217;s in wide use, it&#8217;s the most difficult language to write securely. I would fathom that Assembly is actually easier to write securely than C. To be honest, and you&#8217;ll find out that I&#8217;m very honest, I don&#8217;t think that anybody should be writing new C code.</p>
<p class="noindent">If that&#8217;s the case, then why am I teaching you C? Because I want you to become a better, stronger programmer, and there are two reasons why C is an excellent language to learn if you want to get better. First, C&#8217;s lack of nearly every modern safety feature means you have to be more vigilant and more aware of what&#8217;s going on. If you can write secure, solid C code, you can write secure, solid code in any programming language. The techniques you learn will translate to every language you use from now on. Second, learning C gives you direct access to a mountain of legacy code, and teaches you the base syntax of a large number of descendant languages. Once you learn C, you can more easily learn C++, Java, Objective-C, and JavaScript, and even other languages become easier to learn.</p>
<p class="noindent">I don&#8217;t want to scare you away by telling you this, because I plan to make this book incredibly fun, easy, and devious. I&#8217;ll make it fun to learn C by giving you projects that you might not have done in other programming languages. I&#8217;ll make this book easy by using my proven pattern of exercises that has you <em>doing</em> C programming and building your skills slowly. I&#8217;ll make it devious by teaching you how to break and then secure your code so you understand why these issues matter. You&#8217;ll learn how to cause stack overflows, illegal memory access, and other common flaws that plague C programs so that you know what you&#8217;re up against.</p>
<p class="noindent">Getting through this book will be challenging, like all of my books, but when you&#8217;re done you will be a far better and more confident programmer.</p>
<div class="heading">
<h3 id="pref03lev1sec1"><a id="page_xvi"/>The Undefined Behaviorists</h3>
<p class="noindent">By the time you&#8217;re done with this book, you&#8217;ll be able to debug, read, and fix almost any C program you run into, and then write new, solid C code should you need to. However, I&#8217;m not really going to teach you official C. You&#8217;ll learn the language, and you&#8217;ll learn how to use it well, but official C isn&#8217;t very secure. The vast majority of C programmers out there simply don&#8217;t write solid code, and it&#8217;s because of something called <em>Undefined Behavior</em> (UB). UB is a part of the American National Standards Institute (ANSI) C standard that lists all of the ways that a C compiler can disregard what you&#8217;ve written. There&#8217;s actually a part of the standard that says if you write code like this, then all bets are off and the compiler doesn&#8217;t have to do anything consistently. UB occurs when a C program reads off the end of a string, which is an incredibly common programming error in C. For a bit of background, C defines strings as blocks of memory that end in a NUL byte, or a 0 byte (to simplify the definition). Since many strings come from outside the program, it&#8217;s common for a C program to receive a string without this NUL byte. When it does, the C program attempts to read past the end of this string and into the memory of the computer, causing your program to crash. Every other language developed after C attempts to prevent this, but not C. C does so little to prevent UB that every C programmer seems to think it means they don&#8217;t have to deal with it. They write code full of potential NUL byte overruns, and when you point them out to these programmers, they say, &#8220;Well that&#8217;s UB, and I don&#8217;t have to prevent it.&#8221; This reliance on C&#8217;s large number of UBs is why most C code is so horribly insecure.</p>
</div>
<p class="noindent">I write C code to try to avoid UB by either writing code that doesn&#8217;t trigger it, or writing code that attempts to prevent it. This turns out to be an impossible task because there is <em>so much</em> UB that it becomes a Gordian knot of interconnected pitfalls in your C code. As you go through this book, I&#8217;ll point out ways you can trigger UB, how to avoid it if you can, and how to trigger it in other people&#8217;s code if possible. However, you should keep in mind that avoiding the nearly random nature of UB is almost impossible, and you&#8217;ll just have to do your best.</p>
<div class="note"><hr/>
<p class="title">Warning!</p>
<p class="sb-noindent">You&#8217;ll find that hardcore C fans frequently will try to beat you up about UB. There&#8217;s a class of C programmers who don&#8217;t write very much C code but have memorized all of the UB just so they could beat up a beginner intellectually. If you run into one of these abusive programmers, please ignore them. Often, they aren&#8217;t practicing C programmers, they are arrogant, abusive, and will only end up asking you endless questions in an attempt to prove their superiority rather than helping you with your code. Should you ever need help with your C code, simply email me at <a href="mailto:help@learncodethehardway.org">help@learncodethehardway.org</a>, and I will gladly help you.</p>
<hr/></div>
<div class="heading">
<h3 id="pref03lev1sec2"><a id="page_xvii"/>C Is a Pretty and Ugly Language</h3>
<p class="noindent">The presence of UB though is one more reason why learning C is a good move if you want to be a better programmer. If you can write good, solid C code in the way I teach you, then you can survive <em>any</em> language. On the positive side, C is a really elegant language in many ways. Its syntax is actually incredibly small given the power it has. There&#8217;s a reason why so many other languages have copied its syntax over the last 45 or so years. C also gives you quite a lot using very little technology. When you&#8217;re done learning C, you&#8217;ll have an appreciation for a something that is very elegant and beautiful but also a little ugly at the same time. C is old, so like a beautiful monument, it will look fantastic from about 20 feet away, but when you step up close, you&#8217;ll see all the cracks and flaws it has.</p>
</div>
<p class="noindent">Because of this, I&#8217;m going to teach you the most recent version of C that I can make work with recent compilers. It&#8217;s a practical, straightforward, simple, yet complete subset of C that works well, works everywhere, and avoids many pitfalls. This is the C that I use to get real work done, and not the encyclopedic version of C that hardcore fans try and fail to use.</p>
<p class="noindent">I know the C that I use is solid because I spent two decades writing clean, solid C code that powered large operations without much failure at all. My C code has probably processed trillions of transactions because it powered the operations of companies like Twitter and airbnb. It rarely failed or had security attacks against it. In the many years that my code powered the Ruby on Rails Web world, it&#8217;s run beautifully and even prevented security attacks, while other Web servers fell repeatedly to the simplest of attacks.</p>
<p class="noindent">My style of writing C code is solid, but more importantly, my mind-set when writing C is one every programmer should have. I approach C, and any programming, with the idea of preventing errors as best I can and assuming that nothing will work right. Other programmers, even supposedly good C programmers, tend to write code and assume everything will work, but rely on UB or the operating system to save them, neither of which will work as a solution. Just remember that if people try to tell you that the code I teach in this book isn&#8217;t &#8220;real C.&#8221; If they don&#8217;t have the same track record as me, maybe you can use what I teach you to show them why their code isn&#8217;t very secure.</p>
<p class="noindent">Does that mean my code is perfect? No, not at all. This is C code. Writing perfect C code is impossible, and in fact, writing perfect code in any language is impossible. That&#8217;s half the fun and frustration of programming. I could take someone else&#8217;s code and tear it apart, and someone could take my code and tear it apart. All code is flawed, but the difference is that I try to assume my code is always flawed and then prevent the flaws. My gift to you, should you complete this book, is to teach you the <em>defensive programming</em> mind-set that has served me well for two decades, and has helped me make high-quality, robust software.</p>
<div class="heading">
<h3 id="pref03lev1sec3"><a id="page_xviii"/>What You Will Learn</h3>
<p class="noindent">The purpose of this book is to get you strong enough in C that you&#8217;ll be able to write your own software with it or modify someone else&#8217;s C code. After this book, you should read Brian Kernighan and Dennis Ritchie&#8217;s <em>The C Programming Language</em>, Second Edition (Prentice Hall, 1988), a book by the creators of the C language, also called <em>K&#38;R C</em>. What I&#8217;ll teach you is</p>
</div>
<p class="indenthangingB">&#8226; The basics of C syntax and idioms</p>
<p class="indenthangingB">&#8226; Compilation, <code>make</code> files, linkers</p>
<p class="indenthangingB">&#8226; Finding bugs and preventing them</p>
<p class="indenthangingB">&#8226; Defensive coding practices</p>
<p class="indenthangingB">&#8226; Breaking C code</p>
<p class="indenthangingB">&#8226; Writing basic UNIX systems software</p>
<p class="noindent">By the final exercise, you will have more than enough ammunition to tackle basic systems software, libraries, and other smaller projects.</p>
<div class="heading">
<h3 id="pref03lev1sec4">How to Read This Book</h3>
<p class="noindent">This book is intended for programmers who have learned at least one other programming language. I refer you to my book <em>Learn Python the Hard Way</em> (Addison-Wesley, 2013) if you haven&#8217;t learned a programming language yet. It&#8217;s meant for beginners and works very well as a first book on programming. Once you&#8217;ve completed <em>Learn Python the Hard Way</em>, then you can come back and start this book.</p>
</div>
<p class="noindent">For those who&#8217;ve already learned to code, this book may seem strange at first. It&#8217;s not like other books where you read paragraph after paragraph of prose and then type in a bit of code here and there. Instead, there are videos of lectures for each exercise, you code right away, and then I explain what you just did. This works better because it&#8217;s easier for me to explain something you&#8217;ve already done than to speak in an abstract sense about something you aren&#8217;t familiar with at all.</p>
<p class="noindent">Because of this structure, there are a few rules that you <em>must</em> follow in this book:</p>
<p class="indenthangingB">&#8226; Watch the lecture video first, unless the exercise says otherwise.</p>
<p class="indenthangingB">&#8226; Type in all of the code. Don&#8217;t copy-paste!</p>
<p class="indenthangingB">&#8226; Type in the code exactly as it appears, even the comments.</p>
<p class="indenthangingB">&#8226; Get it to run and make sure it prints the same output.</p>
<p class="indenthangingB">&#8226; If there are bugs, fix them.</p>
<p class="indenthangingB"><a id="page_xix"/>&#8226; Do the Extra Credit, but it&#8217;s all right to skip anything you can&#8217;t figure out.</p>
<p class="indenthangingB">&#8226; Always try to figure it out first before trying to get help.</p>
<p class="noindent">If you follow these rules, do everything in the book, and still can&#8217;t code C, then you at least tried. It&#8217;s not for everyone, but just trying will make you a better programmer.</p>
<div class="heading">
<h3 id="pref03lev1sec5">The Videos</h3>
<p class="noindent">Included in this course are videos for every exercise, and in many cases, more than one video for an exercise. These videos should be considered essential to get the full impact of the book&#8217;s educational method. The reason for this is that <em>many</em> of the problems with writing C code are interactive issues with failure, debugging, and commands. C requires much more interaction to get the code running and to fix problems, unlike languages like Python and Ruby where code just runs. It&#8217;s also much easier to show you a video lecture on a topic, such as pointers or memory management, where I can demonstrate how the machine is actually working.</p>
</div>
<p class="noindent">I recommend that as you go through the course, you plan to watch the videos first, and then do the exercises unless directed to do otherwise. In some of the exercises, I use one video to present a problem and then another to demonstrate the solution. In most of the other exercises, I use a video to present a lecture, and then you do the exercise and complete it to learn the topic.</p>
<div class="heading">
<h3 id="pref03lev1sec6">The Core Competencies</h3>
<p class="noindent">I&#8217;m going to guess that you have experience using a <em>lesser</em> language. One of those <em>usable</em> languages that lets you get away with sloppy thinking and half-baked hackery like Python or Ruby. Or, maybe you use a language like LISP that pretends the computer is some purely functional fantasy land with padded walls for little babies. Maybe you&#8217;ve learned Prolog, and you think the entire world should just be a database where you walk around in it looking for clues. Even worse, I&#8217;m betting you&#8217;ve been using an integrated development environment (IDE), so your brain is riddled with memory holes, and you can&#8217;t even type an entire function&#8217;s name without hitting CTRL-SPACE after every three characters.</p>
</div>
<p class="noindent">No matter what your background is, you could probably use some improvement in these areas:</p>
<div class="heading">
<h4 id="pref03lev2sec1">Reading and Writing</h4>
<p class="noindent">This is especially true if you use an IDE, but generally I find programmers do too much skimming and have problems reading for comprehension. They&#8217;ll just skim code that they need to understand in detail without taking the time to understand it. Other languages provide tools that let programmers avoid actually writing any code, so when faced with a language like C, they break down. The simplest thing to do is just understand that <em>everyone</em> has this problem, and you can fix it by forcing yourself to slow down and be meticulous about your reading and writing. At first, it&#8217;ll feel painful and annoying, but take frequent breaks, and then eventually it&#8217;ll be easier to do.</p>
</div>
<div class="heading">
<h4 id="pref03lev2sec2"><a id="page_xx"/>Attention to Detail</h4>
<p class="noindent">Everyone is bad at this, and it&#8217;s the biggest cause of bad software. Other languages let you get away with not paying attention, but C demands your full attention because it&#8217;s right in the machine, and the machine is very picky. With C, there is no &#8220;kind of similar&#8221; or &#8220;close enough,&#8221; so you need to pay attention. Double check your work. Assume everything you write is wrong until you prove it&#8217;s right.</p>
</div>
<div class="heading">
<h4 id="pref03lev2sec3">Spotting Differences</h4>
<p class="noindent">A key problem that people who are used to other languages have is that their brains have been trained to spot differences in <em>that</em> language, not in C. When you compare code you&#8217;ve written to my exercise code, your eyes will jump right over characters you think don&#8217;t matter or that aren&#8217;t familiar. I&#8217;ll be giving you strategies that force you to see your mistakes, but keep in mind that if your code is not <em>exactly</em> like the code in this book, it&#8217;s wrong.</p>
</div>
<div class="heading">
<h4 id="pref03lev2sec4">Planning and Debugging</h4>
<p class="noindent">I love other, easier languages because I can just hang out. I can type the ideas I have into their interpreter and see results immediately. They&#8217;re great for just hacking out ideas, but have you noticed that if you keep doing <em>hack until it works</em>, eventually nothing works? C is harder on you because it requires you to first plan out what you want to create. Sure, you can hack for a bit, but you have to get serious much earlier in C than in other languages. I&#8217;ll be teaching you ways to plan out key parts of your program before you start coding, and this will likely make you a better programmer at the same time. Even just a little planning can smooth things out down the road.</p>
</div>
<p class="noindent">Learning C makes you a better programmer because you are forced to deal with these issues earlier and more frequently. You can&#8217;t be sloppy about what you write or nothing will work. The advantage of C is that it&#8217;s a simple language that you can figure out on your own, which makes it a great language for learning about the machine and getting stronger in these core programming skills.</p>
</body>
</html>